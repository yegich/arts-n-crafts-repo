package yega.alogorithms.randomizecontraction;

import static java.lang.String.format;

import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.Set;

import org.apache.log4j.Logger;

public class RandomizeContracionAlgorithm {

	private static Logger LOG = Logger.getLogger(RandomizeContracionAlgorithm.class);
	
	private final static Vertex EMPTY_VERTEX = new Vertex.Builder().id("EMPTY").build();
	
	private Map<Vertex, Set<Edge>> vertices;
	private Map<Edge, Set<Vertex>> edges;
	private List<GraphConnection> connections;
	
	public RandomizeContracionAlgorithm() {
		vertices = new HashMap<Vertex, Set<Edge>>();
		edges = new HashMap<Edge, Set<Vertex>>();
		connections = new LinkedList<GraphConnection>();
	}
	
	public void connectVertices(Vertex beginVertex, Vertex endVertex, Edge edge) {
		addVertex(beginVertex,edge);
		addVertex(endVertex,edge);
		addEdge(edge,beginVertex,endVertex);
		connections.add(new GraphConnection.Builder(beginVertex, endVertex, edge).build());
		LOG.debug(String.format("Edge [%s] connected two vertices [%s : %s]", edge, beginVertex, endVertex));
	}
	
	private void addEdge(Edge e, Vertex bV, Vertex eV) {
		if(edges.containsKey(e)) {
			edges.remove(e);
		}
		if (EMPTY_VERTEX.equals(eV) || EMPTY_VERTEX.equals(bV)) {
			return;
		}
		Set<Vertex> vs = new HashSet<Vertex>();
		vs.add(bV); vs.add(eV);
		edges.put(e, vs);
	}

	private void addVertex(Vertex v, Edge e) {
		if(vertices.containsKey(v)) {
			vertices.get(v).add(e);
		} else {
			Set<Edge> es = new HashSet<Edge>();
			es.add(e); 
			vertices.put(v, es);
		}
	}

	public Edge selectRandomEdge() {
		Random randomGenerator = new Random();
		int edgeIndex = randomGenerator.nextInt(edges.keySet().size());
		Integer i = 0;
		Edge edge = null;
		for (Edge tmpEdge : edges.keySet()) {
			if(i == edgeIndex) {
				edge = tmpEdge;
				break;
			} else {
				i++;
			}
		}
		LOG.debug(format("Selected edge is : [%s]", edge));
		return edge;
	}
	
	public GraphConnection selectRandomConnection() {
		Random randomGenerator = new Random();
		int index = randomGenerator.nextInt(connections.size());
		GraphConnection c = connections.get(index);
		LOG.debug(format("Selected connection is : [%s]",  c));
		return c;
	}

	public void contractConnetion(GraphConnection connection) {
		Vertex superVertex = new Vertex.Builder().id(
				connection.getBegin().getId() + "_"
						+ connection.getEnd().getId()).build();
		connections.remove(connection);
		
		for(GraphConnection c : connections) {
			if(c.getBegin().equals(connection.getBegin())) {
				c.setBegin(superVertex);
			}
			if(c.getBegin().equals(connection.getEnd())) {
				c.setBegin(superVertex);
			}
			if(c.getEnd().equals(connection.getBegin())) {
				c.setBegin(superVertex);
			}
			if(c.getEnd().equals(connection.getEnd())) {
				c.setBegin(superVertex);
			}
		}
	}
	public Set<Edge> contractEdge(Edge edge) {
		Set<Vertex> verticesToReplace = edges.get(edge);
		Vertex superVertex = createSuperVertex(verticesToReplace);
		edges.remove(edge);
		
		//remove begin and end vertices
		for (Vertex v : verticesToReplace) {
			if(vertices.get(v) == null) {
				continue;
			}
			for(Edge e : vertices.get(v)) {
				addVertex(superVertex, e);
			}
			vertices.remove(v);
		}
		//replace begin end vertices by super vertex
		Set<Edge> tmpEdges = vertices.get(superVertex);
		if( tmpEdges != null) {
		for(Edge e : vertices.get(superVertex)) {
			addEdge(e, superVertex, getOpositeVertex(verticesToReplace, e));
		}
		}
		return edges.keySet();
	}
	
	private static Vertex createSuperVertex(Set<Vertex> vs) {
		StringBuilder idBuilder = new StringBuilder();
		for(Vertex v : vs) {
			idBuilder.append(v.getId());
		}
		return new Vertex.Builder().id(idBuilder.toString()).build();
	
	}
	
	private Vertex getOpositeVertex(Set<Vertex> vs, Edge e) {
		Vertex oposite = EMPTY_VERTEX;
		if (edges.get(e) != null) {
			for (Vertex tmpV : edges.get(e)) {
				if (!vs.contains(tmpV)) {
					oposite = tmpV;
				}
			}
		}
		return oposite;
	}

	public Integer findMinCut() {
		Integer mincut = null;
		while(true) {
			if(vertices.keySet().size() <= 2 || edges.isEmpty()) {
				break;
			}
			mincut = contractEdge(selectRandomEdge()).size();
			LOG.info(String.format("The mincut this time is [%d]",mincut));
		}
		return mincut;
	}
	public Integer findMinCut2() {
		Integer mincut = null;
		while(true) {
			Set<Vertex> vs = new HashSet<Vertex>();
			for(GraphConnection c : connections) {
				vs.add(c.getBegin());
				vs.add(c.getEnd());
			}
			
			if(vs.size() <= 2) {
				break;
			}
			mincut = contractEdge(selectRandomEdge()).size();
			LOG.info(String.format("The mincut this time is [%d]",mincut));
		}
		return mincut;
	}

}
