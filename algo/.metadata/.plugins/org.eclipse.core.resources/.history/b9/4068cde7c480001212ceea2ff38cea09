package yega.alogorithms.randomizecontraction;

import static java.lang.String.format;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.Set;

import org.apache.log4j.Logger;

public class RandomizeContracionAlgorithm {

	private static Logger LOG = Logger.getLogger(RandomizeContracionAlgorithm.class);
	
	private List<GraphConnection> connections;
	private Set<Vertex> loadVertexSet;
	public RandomizeContracionAlgorithm() {
		connections = new LinkedList<GraphConnection>();
		loadVertexSet = new HashSet<Vertex>();
	}
	
	public void connectVertices(Vertex beginVertex, Vertex endVertex, Edge edge) {
		if (loadVertexSet.contains(beginVertex) && loadVertexSet.contains(endVertex)) {
			LOG.debug(String.format(
					"Edge [%s] already connected two vertices [%s : %s], SKIPED!", edge,
					beginVertex, endVertex));
		} else {
			loadVertexSet.add(beginVertex);
			loadVertexSet.add(endVertex);
			connections.add(new GraphConnection.Builder(beginVertex, endVertex,edge).build());
			LOG.debug(String.format(
					"Edge [%s] connected two vertices [%s : %s]", edge,
					beginVertex, endVertex));
		}
	}
	

	public GraphConnection selectRandomConnection() {
		Random randomGenerator = new Random();
		int index = randomGenerator.nextInt(connections.size());
		GraphConnection c = connections.get(index);
		LOG.debug(format("Selected connection is : [%s]", c));
		return c;
	}

	public void contractConnetion(GraphConnection connection) {
		Vertex superVertex = new Vertex.Builder().id(
				connection.getBegin().getId() + "_"
						+ connection.getEnd().getId()).build();
		connections.remove(connection);
		LOG.debug(format("Removed directly connection : [%s]",connection));
		for(Iterator<GraphConnection> it = connections.iterator(); it.hasNext();) {
			GraphConnection c = it.next();
			if(c.getBegin().equals(connection.getBegin())) {
				c.setBegin(superVertex);
			}
			if(c.getBegin().equals(connection.getEnd())) {
				c.setBegin(superVertex);
			}
			if(c.getEnd().equals(connection.getBegin())) {
				c.setEnd(superVertex);
			}
			if(c.getEnd().equals(connection.getEnd())) {
				c.setEnd(superVertex);
			}
			
			if(c.getBegin().equals(c.getEnd())) {
				it.remove();
				LOG.debug(format("Removed loop connection : [%s]",c));
			}
		}
	}
	
	public Integer findMinCut2() {
		Integer mincut = null;
		while(true) {
			Set<Vertex> vs = new HashSet<Vertex>();
			for(GraphConnection c : connections) {
				vs.add(c.getBegin());
				vs.add(c.getEnd());
			}
			
			if(vs.size() == 2) {
				break;
			}
			contractConnetion(selectRandomConnection());
			mincut = connections.size();
		}
		LOG.info(String.format("The mincut this time is [%d]",mincut));
		return mincut;
	}

}
